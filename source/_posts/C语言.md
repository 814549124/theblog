---
title: C语言
date: 2019-11-22 09:02:18
tags: C
---

# C语言

## 微软的C语言说明书

它描述了微软C实现的C编程语言. 它是基本`ANSI` C 标准(C89)及其微软扩展

### C的元素

- Token

被编译器识别的基本元素

```
语法
token: 
    keyword
    identifier
    constant
    string-literal
    operator
    punctuator
```

- comment

它是开始于符号`/*`的连续字符集, 被编译器信任为单一空白字符. 注释可以占据多行, 但不能嵌套.

注释可以在允许空白字符的任何地方. 一旦编译器信任注释为一空白字符时, 你不能把注释放在token里面.

注释可以放在代码语句同一行上.

```C
printf( "Hello\n" );  /* Comments can go here */
```

你可以选择把描述性的注释块放于函数/模块之前

```c
/* MATHERR.C illustrates writing an error routine
* for math functions.
*/
```

微软特有的

> 微软支持单行注释
>
> ```c
> // this is a valid commnet
> ```
>
> 开始于字符`//`的注释被下一个newline字符终止, 一个逃脱字符不能先于newline字符. 在下面的例子里, 先于`\`字符的newline字符, 创建一个"逃脱顺序". 它让编译器信任下一行为上一行的部分.
>
> ```c
> // my comment \
> 	i++;
> ```
>
> 因此, 该`i++`被注释了
>
> 微软C的默认是它是启动的. 使用/Za 来禁用

- C关键词

它对于C编译器有几种不同意思. 在翻译阶段7和8里, 标识符不能如C关键词一样的拼写. C语言的关键词有:

| **auto**     | **double** | **int**      | **struct**   |
| ------------ | ---------- | ------------ | ------------ |
| **break**    | **else**   | **long**     | **switch**   |
| **case**     | **enum**   | **register** | **typedef**  |
| **char**     | **extern** | **return**   | **union**    |
| **const**    | **float**  | **short**    | **unsigned** |
| **continue** | **for**    | **signed**   | **void**     |
| **default**  | **goto**   | **sizeof**   | **volatile** |
| **do**       | **if**     | **static**   | **while**    |

你不能从定义关键词. 不过, 在编译之前,你可以指明文本为关键词的代替物, 通过使用C预处理指令

微软特有的

> ANSI C标准运行带有`__`的标识符为编译器的实现做保留用. 因此微软的惯例是在微软特有的关键词前加`__`.
>
> 有微软C编译器识别为关键词有:
>
> | **__asm **3      | **dllimport **2 | **__int8** 3  | **naked **2     |
> | ---------------- | --------------- | ------------- | --------------- |
> | **__based **1, 3 | **__except **3  | **__int16 **3 | **__stdcall **3 |
> | **__cdecl** 3    | **__fastcall**  | **__int32 **3 | **thread **2    |
> | **__declspec **3 | **__finally **3 | **__int64 **3 | **__try **3     |
> | **dllexport **2  | **__inline **3  | **__leave** 3 |                 |
>
> `__based`关键词对32位和64位编译来说有限制
>
> `2` 它们是特殊标识符,在用于`__declspec`的时候; 它们用于其它上下文里是没有限制的
>
> `3`为兼容性考虑, 当微软扩展启动时, 这些关键词都有效于`__`和`_`的
>
> 微软扩展默认是启动的.

- C标识符

它们是名称, 你在你的程序里为变量,类型,函数和label提供的. 标识符的名称必须不同于关键词. 你通过在变量,类型,函数的声明里来创建标识符.

一旦声明了, 在之后的程序语句里,你能使用标识符来引用分配了的值.

标识符的特殊类型, 称语句`label`, 能用于`goto`语句.

> 语法
>
> identifier:
>
> ​	nondigit
>
> ​	identifier nondigit
>
> ​	identifier digit
>
> nondigit: one of
>
>   **_ a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L MN O P Q R S T U V W X Y Z** 
>
> digit: one of
>
> ​	**0 1 2 3 4 5 6 7 8 9**

ANSI 在一个外部标识符名称里允许六个有意义的字符, 在内部(函数里)标识符名称里允许31个. 外部标识符(在全局作用域里声明或用存储类`extern`来声明) 必须是额外的命名限制的subject,因为这些标识符被其他软件如linker所处理

> 微软特有的
>
> 尽管ANSI允许6/31字符, 微软C编译器在内部和外部标识符名称里允许247个字符. 如果你不关心与ANSI的兼容, 你可以修改这默认为更小或更大数, 使用`/H`选项

C编译器是大小写敏感的.

> 不要选择标识符的名称, 开始于`__`或`_`再随着一个大写字符. 在ANSI C标识,这组合是保留为编译器使用的. 文件等级的作用域也不要用`_`和一个小写字符来命名. 它们也是被保留的. 惯例的, 微软使用一个`_`和一个大写字符来开始宏名称,和使用`__`来开始为微软特有的关键词名称. 为了避免任何命名冲突, 总是选择不开始于一个或两下划线的标识符名词,或者不开始于一个下划线带有一个大写字符的标识符名词.

> 尽管源文件里的标识符是大小写敏感的, 在对象文件里的符号则不是. 微软C信任在编译单元里的标识符是大小写敏感.
>
> 微软的linker是大小写敏感的.
>
> 该"源字符集"是能出现在源文件里的合法字符的集合. 对于微软C,源集是标准的ASCII字符集. 源字符集和执行字符集包含ASCII字符, 用作一个逃脱序列

标识符有`作用域`, 它是在程序里标识符被知道的程序的区域, 和`linkage`,它决定在其他作用域的相同的名称是否引用为相同的标识符.

- C常量

它是数值,字符,字符串, 用作在程序里的值. 使用常量来代表浮游点,整数,枚举,字符值是不能被修改的

- C string literal

它是来自源字符集的被`""`包围的连续字符. 它用于代表字符的连续, 以null终止字符串的形式. 你必须总是用**L**来前缀宽的string literal.

> 语法
>
> string-literal:
>
> ​	**"** s-char-sequence **"**
>
> ​    L**"** s-char-sequence **"**
>
> s-char-sequence:
>
> ​	s-char
>
> ​	s-char-sequence s-char
>
> s-char:
>
> ​	源字符集的任何成员, 除了双引号,反斜号,新行字符串
>
> ​	escape-sequence



### 程序结构

该章节给出了C程序和程序执行的预览. 术语和特性是重要的来理解C程序和组件.

#### 源文件和源程序

源程序可以分为一个或多个源文件或翻译单位. 编译器的输出被称为翻译单位

> 语法
>
> translation-unit:
>
> ​	external-declaration
>
> ​	translation-unit external-declaration
>
> external-declaration:
>
> ​	function-definition
>
> ​	declaration

翻译单元的组件是外部声明. 这些声明和定义是在源文件,头文件,库及其其他文件等. 你必须编译每个翻译单元并连接这些产出的对象文件来制作程序.

一个C源程序是指令,pragmas,声明,定义,语句块和函数的集合.为了微软C程序的组件有效, 每个组件必须有描述在该书里的语法, 尽管他们能以任何顺序在程序里出现. 然而这些组件的位置会影响变量和函数在程序里如何被使用.

源文件不需要包含可执行语句. 例如, 你可能发觉它是有用的,放置在一个源文件里的变量的定义的地方, 然后声明在其他我们为使用该变量的源文件里的变量的引用. 该技术让定义在需要时易于寻找和更新. 在相同的原因里, 常量和宏经常组织到不同的文件称"include文件"和"header文件", 在需要时在源文件里被引用.

#### 主要函数和程序执行

任何一个c程序都有一个主要的函数,它必须命名为`main`. 如果你的代码坚持Unicode编程模型,可以使用`main`的宽字符版本`wmain`.该`main`函数左右 程序执行的开始点. 它通常地通过直接调用其他函数来控制程序执行. 程序通常在`main`的结束后停止执行, 尽管它能因不同原因在其他点上终止. 在这时, 可能地在错误被检查到时, 你可能想强制程序的终止动作. 为了做这些, 使用`exit`函数.

#### 解析C命令行参数

**微软特有的**

微软C启动代码, 当解析中的参数在操作系统命令行上得到时,使用下面的规则:

- 参数被空白字符划分开来
- 被双引号包围起来的字符串, 被解释为一个参数, 不管空白字符包含在里面. 被括起来的字符串可以嵌入在一个参数里. `^`字符不能识别为逃脱字符和分解符
- `\"`, 被解释为一个字面`"`
- 反斜号被字面地解释,除非他们立即先于一个`"`
- 如果偶数个反斜号,被`"`所跟随, 那么, 为每对反斜号而把一个斜号放置在argv数组里, 并且一个双引号被解释为一个字符串定界符
- 如果奇数个反斜号,被`"`所跟随, 那么,为每对反斜号而把一个斜号放置在argv数组里, 然后`"`被解释为一个escape sequence, 会引起字面`"`被放置在argv里

例如

| Command-Line Input | argv[1]  | argv[2] | argv[3] |
| :----------------- | :------- | :------ | :------ |
| `"a b c" d e`      | `a b c`  | `d`     | `e`     |
| `"ab\"c" "\\" d`   | `ab"c`   | `\`     | `d`     |
| `a\\\b d"e f"g h`  | `a\\\b`  | `de fg` | `h`     |
| `a\\\"b c d`       | `a\"b`   | `c`     | `d`     |
| `a\\\\"b c" d e`   | `a\\b c` | `d`     | `e`     |

#### Lifetime 生存时间

它是在一个变化和函数存在的程序的执行里的一段时间. 标识符的存储持续决定了它的生存时间

一个用存储类指定符`static`声明的标识符用于**静态存储持续**.

带有静态存储持续的标识符(也称为全局)拥有存储空间和一个关于程序的持续的已定于的值. 存储空间是被保留的, 在程序启动之前,标识符的存储了的值仅一次地被初始化. 带有外部和内部linkage声明的标识符也拥有静态存储持续.

不带有`static`指示符声明的标识符,如果他声明在函数里,则拥有自动存储持续. 带有自动存储持续的标识符(本地标识符)拥有一个存储空间和一个仅仅在该标识符已定义的或声明的块内部里的已定于的值. 自动标识符在每次程序进入该块时被分配一个新存储空间, 并且在程序退出块时丢失它的存储空间. 声明在一个函数里的没有linkage的标识符也拥有自动存储持续.

下面的规则指明了一个标识符是否有全局和本地的生存空间:

- 所有函数拥有静态生成空间. 声明在外部等级的标识符总是拥有全局(静态)生存空间
- 如果本地变量有一个初始化器, 变量在每次它被创建时被初始化(声明为`static`的除外).函数的参数拥有本地生存空间. 你能指明全局. 一旦声明为`static`,该变量从块的入库到下一块中维持着它的值.



#### 作用域和可见性

一个标识符的"可见性"决定了它能被引用在程序里(作用域)的程序的部分. 一个标识符是可见的,仅在被它的作用域包围的程序的部分, 标识符能被它出现在文件,函数,块,函数prototype的文件,函数,块,函数prototype所限制. 这也是某时它被称为"词汇作用域"的原因. 这里有四种类似的作用域: 文件,函数,块和函数prototype.

除了label外的所有标识符,拥有他们的作用域,被该声明发生在该level的level所决定. 下面各种作用域的规则管理着标识符的可见性:

文件作用域: 关于一个文件作用域里标识符的声明器和类型指明符出现在任何块的外部,或者它对来自声明之后的翻译单元里的任何地方是可访问的. 带有文件域的标识符名称经常被称为"全局"或"外部". 这标识符的域开始于它的定义点或生命点,终止于翻译单元

函数作用域: 一个label仅仅是用于函数作用域的标识符的类型. 一个label是通过它在一个语句里使用来隐式声明的. label名在有一个函数里必须唯一.

块作用域: 关于带有块域的标识符的声明器和类型指明符出现在一个块里面或在在一个函数定义里的正规的参数声明的列表里. 它仅可见于从它的声明点或定义点到包含它的声明和定义的块的结尾处. 它的域被限制于那块和任何在那块里的嵌套块. 这样的标识符某时被称为"本地变量"

函数-prototype的域: 关于带有该域的标识符的声明器和类型指明符出现在声明在一个函数prototype里的参数列表里. 它的域终止于函数声明器的结尾处.

可见于其他源文件的变量,在存储类里被描述. 不过, 带有`static`声明在外部等级的变量和函数, 仅可见于自身的源文件里.

#### Linkage

标识符名称能在不同域里引用不同标识符. 声明在不同域的或相同域的标识符超过一次引用相同的标识符或函数,被称为"连接". 连接决定了在程序里标识符能被应用的该程序的部分. 这里有三种不同类型的连接:

- internal

  如果文件域的标识符的声明带有`static`这被称为内部连接

- external

  如果文件域的标识符的声明不使用`static`时,这被称为外部连接.

  如果

  带有外部连接的标识符名称指派相同名称的函数和对象为带有外部连接的相同名称的其他声明. 这两种声明可以在相同或不同的翻译单元里. 如果这些对象和函数拥有全局对象, 它们能被完整的程序所共享

- no linkage

  在块里的标识符的声明不包含`extern`指明符时, 该标识符为no linkage和唯一于该函数.

  下列的标识符有no linkage;

  - 标识符声明为非对象和函数的其他任何东西
  - 标识符声明为函数参数
  - 块域标识符而没有`extern`指明符

  如果标识符为no linkage,那么在相同域等级里再次声明相同的名称会生成符合重定义错误